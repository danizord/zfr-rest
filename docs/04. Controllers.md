# Controllers

In this section, we'll cover more advanced concepts of the controller part in ZfrRest.

## Method handlers

A method handler is a specific object that implement the `ZfrRest\Mvc\Controller\MethodHandler\MethodHandlerInterface`
interface. Its task is to perform some logic before and after passing the resource to the controller.

ZfrRest is bundled with handlers for all basic HTTP verbs: `DELETE`, `GET`, `OPTIONS`, `POST` and `PUT`.

Here is, for example, the delete handler:

```php
use ZfrRest\Mvc\Controller\AbstractRestfulController;

class DeleteHandler implements MethodHandlerInterface
{
    public function handleMethod(AbstractRestfulController $controller, ResourceInterface $resource)
    {
        // If no delete method is defined on the controller, then we cannot do anything
        if (!method_exists($controller, 'delete')) {
            throw new MethodNotAllowedException();
        }

        $result = $controller->delete($resource->getData(), $resource->getMetadata());

        // According to http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.7, status code should
        // be 204 if nothing is returned
        if (empty($result)) {
            $controller->getResponse()->setStatusCode(204);
        }

        return $result;
    }
}
```

As you can see, the handler first checks if the `delete` method exists on your controller, and throw a
`MethodNotAllowedException` otherwise.

It then gives the resource (for instance, a User object) to your controller so that you can perform the logic of
deleting the resource. Then, it performs various checks to be as compliant as possible with various standards.

Some handlers are most complex, because they perform validation and hydration (for instance post and put handlers).

### Overriding existing handlers

If you want to override an existing handler to perform your own logic, you can altering the
`MethodHandlerPluginManager` configuration. In your config, add the following:

```php
return [
    'zfr_rest' => [
        'method_handlers' => [
            'invokables' => [
                'get' => 'Application\Handler\CustomGetHandler'
            ]
        ]
    ]
];
```

### Adding handler for custom verbs

Alternatively, you can add support for custom HTTP verbs exactly the same way as outlines before:

```php
return [
    'zfr_rest' => [
        'method_handlers' => [
            'invokables' => [
                'funkyVerb' => 'Application\Handler\FunkyVerbHandler'
            ]
        ]
    ]
];
```

Now, you can have a `funkyVerb` method in your REST controllers, and it will be interpreted by ZfrRest.

## Context resource

When dealing with requests such as POST `/users/1/tweets`, you will receive a Tweet instance as the parameter
of the POST method in the tweet controller. However, you may need to have the context that was used to match
this resource. In this case, the user nÂ°1.

Because the router traverses the whole path, it keeps track of all the matched resources. ZfrRest controllers offer
a simple way to retrieve the previous matched resource (aka. the context) through the use of the `getContextResource`
method:

```php
class TweetListController extends AbstractRestfulController
{
    public function post(Tweet $tweet)
    {
        $userResource = $this->getContextResource(); // $userResource is a ResourceInterface object
    }
}
```

ZfrRest only supports going back one level in the hierarchy.

## Override controllers on associations

An association can be accessed on different paths. For instance, you may want to access the tweets from two different
paths: either accessing all the tweets using the `/tweets` URI, or accessing all the tweets from a given user using
the `/users/:id/tweets` URI.

However, you may often want to have different logic (permissions, rendering...) depending on the URI. To that extent,
you can use the `collectionController` on the association mapping:

```php
class User
{
    /**
     * @REST\Association(routable=true, collectionController="Tweet\Controller\UserTweetListController")
     */
    protected $tweets;
}
```

Now, the `/tweets` URL (if exposed) will be dispatched to the collection controller defined on the `Tweet` mapping,
but the `/users/4/tweets` will be dispatched to the `Tweet\Controller\UserTweetListController`.

> As of now, you cannot override the controller on association for single resource. This means that `/users/2/tweets/4`
will be dispatched to the controller defined on the `Resource` mapping of the Tweet entity.

## Using controller events

ZfrRest offers a lot of events that you can use to override default behaviours of ZfrRest. Those events can be listened
in a any controller. Here is a full list of events:

* `ZfrRest\Mvc\Controller\Event\ValidationEvent::EVENT_VALIDATE_PRE`: this event is triggered before ZfrRest validates
any data. You can use this event to override the input filter (that is fetched from mapping, by default), to prevent
auto filtering...
* `ZfrRest\Mvc\Controller\Event\ValidationEvent::EVENT_VALIDATE_ERROR`: this event is triggered when an input filter
validation fails.
* `ZfrRest\Mvc\Controller\Event\ValidationEvent::EVENT_VALIDATE_SUCCESS`: this event is triggered when an input filter
validation is successful.
* `ZfrRest\Mvc\Controller\Event\HydrationEvent::EVENT_HYDRATE_PRE`: this event is triggered before ZfrRest automatically
hydrates an object. You can use this event to prevent this behaviour or to specify a custom hydrator.
* `ZfrRest\Mvc\Controller\Event\HydrationEvent::EVENt_HYDRATE_POST`: this event is triggered when an object has been
hydrated.

The next few sections will show you some specific use cases.

### Preventing auto filtering and/or auto validation

By default, ZfrRest does a lot of things automatically for you. For instance, when doing a `POST` or `PUT` request,
it automatically validates the data and create a new object using a hydrator, so that your controller directly
receive a ready-to-consume object.

However, you may want to keep control on those steps, and doing the validation and hydration yourself. You can use
the `ValidationEvent::EVENT_VALIDATE_PRE`. Here is the full example:

```php
use ZfrRest\Mvc\Controller\AbstractRestfulController;
use ZfrRest\Mvc\Controller\Event\ValidationEvent;
use ZfrRest\Mvc\Controller\Event\HydrationEvent;

class PasswordResetListController extends AbstractRestfulController
{
    public function post(array $data)
    {
        // For instance
        $passwordReset = $this->passwordResetService->createFromEmail($data['email']);

        return $this->resourceModel($passwordReset);
    }

    protected function attachDefaultListeners()
    {
        parent::attachDefaultListeners(); // Don't forget that!

        $eventManager = $this->getEventManager();
        $eventManager->attach(ValidationEvent::EVENT_VALIDATION_PRE, [$this, 'preventAutoFiltering']);
        $eventManager->attach(HydrationEvent::EVENT_HYDRATION_PRE, [$this, 'preventAutoHydration']);
    }

    public function preventAutoFiltering(ValidationEvent $event)
    {
        if ($this->request->isPost()) {
            $event->setAutoValidate(false);
        }
    }

    public function preventAutoHydration(HydrationEvent $event)
    {
        if ($this->request->isPost()) {
            $event->setAutoHydrate(false);
        }
    }
}
```

As you can see, we are overriding the `attachDefaultListeners` and attach two new listeners. If the method is POST,
then we disable auto filtering and auto hydration.

With this code, ZfrRest won't validate nor won't hydrate any data, only for the POST method (this is therefore very
flexible!).

> NOTE: Please note that while disabling auto-hydration can be useful, we do not recommend you to disable auto filtering,
as it can causes security issues if you don't correctly validate and filter data yourself!

### Configuring input filters based on context

Quite often, you need different validation rules depending on the HTTP method or things like users's permissions... For
instance, POST method for creating a user may require a first name, a last name and a password. However, you want
restrict updating (PUT method) to only password and last name, so that they cannot change their first name.

Zend Framework 2 input filters offer this feature through so-called validation groups. Validation groups allow to
skip unwanted values and do not return them. As for the previous example, you can use events to do that:

```php
use ZfrRest\Mvc\Controller\AbstractRestfulController;
use ZfrRest\Mvc\Controller\Event\ValidationEvent;
use ZfrRest\Mvc\Controller\Event\HydrationEvent;

class UserController extends AbstractRestfulController
{
    protected function attachDefaultListeners()
    {
        parent::attachDefaultListeners(); // Don't forget that!

        $eventManager = $this->getEventManager();
        $eventManager->attach(ValidationEvent::EVENT_VALIDATION_PRE, [$this, 'configureInputFilter']);
    }

    public function configureInputFilter(ValidationEvent $event)
    {
        // If method is not PUT, we can return early
        if (!$this->request->isPut()) {
            return;
        }

        // We get the default input filter from event, and we can configure it
        $inputFilter = $event->getInputFilter();
        $inputFilter = $inputFilter->setValidationGroup(['last_name', 'password']);
    }
}
```

By default, `getInputFilter` method from the event will create an input filter from the resource mapping. You can
then configure it.

You are not restricted to using validation groups. In some cases, you may need a completely different input filter,
because rules are dramatically different. To do that, just use the `setInputFilter` method of the event:

```php
use Zend\InputFilter\InputFilterPluginManager;
use ZfrRest\Mvc\Controller\AbstractRestfulController;

class UserController extends AbstractRestfulController
{
    protected function attachDefaultListeners()
    {
        parent::attachDefaultListeners(); // Don't forget that!

        $eventManager = $this->getEventManager();
        $eventManager->attach(ValidationEvent::EVENT_VALIDATION_PRE, [$this, 'configureInputFilter']);
    }

    public function configureInputFilter(ValidationEvent $event)
    {
        // If method is not PUT, we can return early
        if (!$this->request->isPut()) {
            return;
        }

        // Otherwise, we create the very specific input filter for PUT method
        $inputFilterManager = $event->getInputFilterManager();
        $inputFilter        = $inputFilterManager->get('UpdateUserInputFilter');

        $event->setInputFilter($inputFilter);
    }
}
```

> By doing this, the input filter defined in the mapping is never instantiated if method is "PUT".

### Navigation

* Continue to [**Built-in listeners**](/docs/05. Built-in listeners.md)
* Back to [Using HTTP exceptions for reporting errors](/docs/03. Using HTTP exceptions for reporting errors.md)
* Back to [the Index](/docs/README.md)
